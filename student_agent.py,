"""
Student Success AI Agent System
Kaggle AI Agents Capstone Project 2025
By Madala Yeshwanth Kumar - Roll No: RK25HBB36
LPU BTech CSE - First Year

Autonomous AI agent system that automates academic deadline tracking,
intelligent study scheduling, multi-channel reminders, and provides an
LLM-powered chatbot assistant for university students.
"""

import os
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from twilio.rest import Client
import google.generativeai as genai
import schedule
import time
import sqlite3
import json

# CONFIGURATION
CONFIG = {
    'ums_username': 'YOUR_REGISTRATION_NUMBER',
    'ums_password': 'YOUR_PASSWORD',
    'google_creds': 'credentials.json',
    'twilio_sid': 'YOUR_TWILIO_SID',
    'twilio_token': 'YOUR_TWILIO_TOKEN',
    'whatsapp_number': '+14155238886',
    'student_phone': '+91XXXXXXXXXX',
    'gemini_key': 'YOUR_GEMINI_API_KEY'
}

# UMS SCRAPER MODULE
class UMSScraper:
    def __init__(self, username, password):
        self.username = username
        self.password = password
        options = webdriver.ChromeOptions()
        options.add_argument('--headless')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        self.driver = webdriver.Chrome(options=options)
        
    def login(self):
        """Login to UMS portal"""
        try:
            self.driver.get('https://ums.lpu.in')
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "username"))
            )
            self.driver.find_element(By.ID, "username").send_keys(self.username)
            self.driver.find_element(By.ID, "password").send_keys(self.password)
            self.driver.find_element(By.ID, "loginButton").click()
            time.sleep(3)
            print("‚úì Successfully logged into UMS")
            return True
        except Exception as e:
            print(f"‚úó Login failed: {e}")
            return False
    
    def get_assignments(self):
        """Extract assignment deadlines"""
        assignments = []
        try:
            self.driver.get('https://ums.lpu.in/assignments')
            time.sleep(2)
            
            # Parse assignment elements
            assignment_elements = self.driver.find_elements(By.CLASS_NAME, "assignment-item")
            for elem in assignment_elements:
                assignment = {
                    'course': elem.find_element(By.CLASS_NAME, "course-code").text,
                    'title': elem.find_element(By.CLASS_NAME, "assignment-title").text,
                    'due_date': elem.find_element(By.CLASS_NAME, "due-date").text,
                    'status': elem.find_element(By.CLASS_NAME, "status").text
                }
                assignments.append(assignment)
            
            print(f"‚úì Found {len(assignments)} assignments")
            return assignments
        except Exception as e:
            print(f"‚úó Error fetching assignments: {e}")
            return []
    
    def get_exams(self):
        """Extract exam schedule"""
        exams = []
        try:
            self.driver.get('https://ums.lpu.in/examinations')
            time.sleep(2)
            
            # Parse exam elements
            exam_elements = self.driver.find_elements(By.CLASS_NAME, "exam-item")
            for elem in exam_elements:
                exam = {
                    'course': elem.find_element(By.CLASS_NAME, "course-code").text,
                    'date': elem.find_element(By.CLASS_NAME, "exam-date").text,
                    'time_start': elem.find_element(By.CLASS_NAME, "start-time").text,
                    'time_end': elem.find_element(By.CLASS_NAME, "end-time").text,
                    'room': elem.find_element(By.CLASS_NAME, "room-number").text,
                    'type': elem.find_element(By.CLASS_NAME, "exam-type").text
                }
                exams.append(exam)
            
            print(f"‚úì Found {len(exams)} exams")
            return exams
        except Exception as e:
            print(f"‚úó Error fetching exams: {e}")
            return []
    
    def get_attendance(self):
        """Extract attendance data"""
        try:
            self.driver.get('https://ums.lpu.in/attendance')
            time.sleep(2)
            attendance = {}
            
            course_elements = self.driver.find_elements(By.CLASS_NAME, "attendance-row")
            for elem in course_elements:
                course = elem.find_element(By.CLASS_NAME, "course-name").text
                percentage = elem.find_element(By.CLASS_NAME, "percentage").text
                attendance[course] = percentage
            
            print(f"‚úì Attendance data retrieved for {len(attendance)} courses")
            return attendance
        except Exception as e:
            print(f"‚úó Error fetching attendance: {e}")
            return {}
    
    def close(self):
        """Close browser"""
        self.driver.quit()

# CALENDAR SYNC ENGINE
class CalendarSync:
    def __init__(self, creds_path):
        self.creds = Credentials.from_authorized_user_file(creds_path)
        self.service = build('calendar', 'v3', credentials=self.creds)
    
    def create_event(self, title, date, time_start, time_end, description):
        """Create Google Calendar event with smart reminders"""
        try:
            event = {
                'summary': title,
                'description': description,
                'start': {
                    'dateTime': f'{date}T{time_start}:00',
                    'timeZone': 'Asia/Kolkata',
                },
                'end': {
                    'dateTime': f'{date}T{time_end}:00',
                    'timeZone': 'Asia/Kolkata',
                },
                'reminders': {
                    'useDefault': False,
                    'overrides': [
                        {'method': 'popup', 'minutes': 7 * 24 * 60},  # 7 days before
                        {'method': 'popup', 'minutes': 3 * 24 * 60},  # 3 days before
                        {'method': 'popup', 'minutes': 24 * 60},      # 1 day before
                        {'method': 'popup', 'minutes': 120},          # 2 hours before
                    ],
                },
                'colorId': '11'  # Red for high priority
            }
            
            event = self.service.events().insert(calendarId='primary', body=event).execute()
            print(f"‚úì Calendar event created: {title}")
            return event.get('htmlLink')
        except Exception as e:
            print(f"‚úó Calendar sync failed: {e}")
            return None

# MESSAGING SYSTEM
class ReminderSystem:
    def __init__(self, config):
        self.client = Client(config['twilio_sid'], config['twilio_token'])
        self.whatsapp = config['whatsapp_number']
        self.student = config['student_phone']
    
    def send_whatsapp(self, message):
        """Send WhatsApp message via Twilio"""
        try:
            self.client.messages.create(
                body=message,
                from_=f'whatsapp:{self.whatsapp}',
                to=f'whatsapp:{self.student}'
            )
            print(f"‚úì WhatsApp sent: {message[:50]}...")
        except Exception as e:
            print(f"‚úó WhatsApp failed: {e}")
    
    def send_sms(self, message):
        """Send SMS"""
        try:
            self.client.messages.create(
                body=message,
                from_=self.whatsapp,
                to=self.student
            )
            print(f"‚úì SMS sent: {message[:50]}...")
        except Exception as e:
            print(f"‚úó SMS failed: {e}")
    
    def daily_digest(self, exams, assignments):
        """Send morning digest"""
        today = datetime.now()
        
        message = f"üìö Good Morning! Today's Focus ({today.strftime('%B %d, %Y')})\n\n"
        
        # Upcoming exams
        message += "üìù Exams:\n"
        for exam in exams[:3]:
            days_until = (datetime.strptime(exam['date'], '%Y-%m-%d') - today).days
            message += f"  ‚Ä¢ {exam['course']}: {days_until} days\n"
        
        # Pending assignments
        message += "\nüìã Assignments Due:\n"
        for assignment in assignments[:3]:
            days_until = (datetime.strptime(assignment['due_date'], '%Y-%m-%d') - today).days
            message += f"  ‚Ä¢ {assignment['title']}: {days_until} days\n"
        
        message += "\nüí™ You've got this! Stay focused."
        
        self.send_whatsapp(message)
        self.send_sms(message)

# AI CHATBOT
class StudentAssistant:
    def __init__(self, api_key):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-pro')
        self.chat = self.model.start_chat(history=[])
    
    def ask(self, question, context=None):
        """Ask AI assistant with context"""
        try:
            prompt = f"Student Data: {context}\n\nQuestion: {question}" if context else question
            response = self.chat.send_message(prompt)
            return response.text
        except Exception as e:
            return f"Error: {e}"
    
    def generate_study_plan(self, exams, days=7):
        """Generate personalized study plan"""
        prompt = f"""Generate a {days}-day study plan for these exams:
        {json.dumps(exams, indent=2)}
        
        Include:
        - Daily topics to cover
        - Time allocation
        - Practice recommendations
        - Rest periods"""
        
        return self.ask(prompt)

# MEMORY DATABASE
class MemoryDB:
    def __init__(self, db_path='student_agent.db'):
        self.conn = sqlite3.connect(db_path)
        self.init_db()
    
    def init_db(self):
        """Initialize database tables"""
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY,
                type TEXT,
                title TEXT,
                date TEXT,
                created_at TIMESTAMP
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS preferences (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        ''')
        self.conn.commit()
    
    def store_event(self, event_type, title, date):
        """Store event in database"""
        cursor = self.conn.cursor()
        cursor.execute(
            'INSERT INTO events (type, title, date, created_at) VALUES (?, ?, ?, ?)',
            (event_type, title, date, datetime.now())
        )
        self.conn.commit()
    
    def get_preferences(self, key):
        """Get user preferences"""
        cursor = self.conn.cursor()
        cursor.execute('SELECT value FROM preferences WHERE key = ?', (key,))
        result = cursor.fetchone()
        return result[0] if result else None

# MAIN AGENT
class StudentSuccessAgent:
    def __init__(self, config):
        self.ums = UMSScraper(config['ums_username'], config['ums_password'])
        self.calendar = CalendarSync(config['google_creds'])
        self.reminders = ReminderSystem(config)
        self.bot = StudentAssistant(config['gemini_key'])
        self.db = MemoryDB()
    
    def sync_all(self):
        """Sync all data from UMS"""
        print("\nüîÑ Starting sync...")
        
        # Login to UMS
        if not self.ums.login():
            print("‚úó Sync failed: Could not login")
            return
        
        # Get all data
        assignments = self.ums.get_assignments()
        exams = self.ums.get_exams()
        attendance = self.ums.get_attendance()
        
        # Sync to Calendar
        for exam in exams:
            title = f"{exam['course']} EXAM"
            self.calendar.create_event(
                title=title,
                date=exam['date'],
                time_start=exam['time_start'],
                time_end=exam['time_end'],
                description=f"Room: {exam['room']}\nType: {exam['type']}"
            )
            self.db.store_event('exam', title, exam['date'])
        
        for assignment in assignments:
            if assignment['status'] != 'Submitted':
                title = f"{assignment['course']} - {assignment['title']}"
                self.calendar.create_event(
                    title=title,
                    date=assignment['due_date'],
                    time_start="23:59",
                    time_end="23:59",
                    description=f"Assignment Due: {assignment['title']}"
                )
                self.db.store_event('assignment', title, assignment['due_date'])
        
        self.ums.close()
        print("‚úì Sync complete!\n")
    
    def run(self):
        """Run agent continuously"""
        print("üöÄ Student Success AI Agent Started!")
        print("=" * 50)
        
        # Schedule tasks
        schedule.every(6).hours.do(self.sync_all)
        schedule.every().day.at("08:00").do(
            lambda: self.reminders.daily_digest(
                self.ums.get_exams(),
                self.ums.get_assignments()
            )
        )
        
        # Initial sync
        self.sync_all()
        
        # Keep running
        while True:
            schedule.run_pending()
            time.sleep(60)

if __name__ == "__main__":
    # Initialize agent
    agent = StudentSuccessAgent(CONFIG)
    
    # Run agent
    agent.run()
